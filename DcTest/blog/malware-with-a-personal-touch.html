<!doctype html>
<!--

    EEEEE  N   N  DDD     GGG     A    M   M  EEEEE
    EE     NN  N  D  D   G       A A   MM MM  EE
    EEEE   N N N  D   D G  GGG  A A A  M M M  EEEE
    EE     N  NN  D  D   G   G  A   A  M   M  EE     ##
    EEEEE  N   N  DDD     GGG   A   A  M   M  EEEEE  ##

    Thanks for checking out our code!
    We are always looking for the most inquisitive and creative front-end developers.
    Contact us at info@endgame.com or check our careers page for openings.

-->
<html lang="en-us" id='top'>

<!-- Mirrored from www.endgame.com/blog/malware-with-a-personal-touch.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 18 Nov 2014 14:43:30 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge;chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <title dir="ltr">Malware with a Personal Touch | Endgame.</title>
    <meta name="description" content="" />
    <link rel="stylesheet" type="text/css" href="http://cloud.typography.com/6815252/750422/css/fonts.css" />
    <link href="../css/app.css" rel="stylesheet" type="text/css" />
</head>
<body class="inner">
    <div id='contact-us' class='js-contact-form'>
    <h1>Sign Up for Endgame News and Communications</h1>
    <form action="https://www.salesforce.com/servlet/servlet.WebToLead?encoding=UTF-8" method="POST">
	<input type=hidden name="oid" value="00Dd0000000e4Bs">
	<input type=hidden name="retURL" value="../index.html">
	<label for="first_name">First Name</label><input  required id="first_name" name="first_name" type="text" /><br>
	<label for="last_name">Last Name</label><input  required id="last_name" name="last_name" type="text" /><br>
	<label for="email">Email</label><input  required id="email" name="email" type="text" /><br>
	<label for="company">Company</label><input  required id="company" name="company" type="text" /><br>
	<label for="title">Title</label><input  required id="title" name="title" type="text" /><br>
	<input type="submit" class='button--red' name="submit">
    </form>
    </div>
    <header role="banner" class="cf">
        <h2>
            <a href="../index.html">
                <img class='logo2' alt="Endgame logo" src="images/logo.png" />
                <div class="period" data-url="/"></div>
            </a>
        </h2>
        <span class="brgr-brdr m" id="brgr-brdr"></span>
        <span class="brgr-menu m" id="brgr-menu"></span>
        <nav>
            <ul id="nav">
                <li>
                    <a href="../capabilities/index.html">Capabilities</a>
                </li>
                <li>
                    <a href="../federal/index.html">Federal</a>
                </li>
                <li>
                    <a href="../about/index.html">About</a>
                </li>
                <li>
                    <a href="../news/index.html">Blog &amp; News</a>
                </li>
                <li>
                    <a href="../careers/index.html">Careers</a>
                </li>
                <li class='contact-dropdown'>
                    <span>
                        <em>Contact</em>
                    </span>
                </li>
                <div id="contact-wrap">
                    <div id="contact">
                        <p class="media">
                            <img src="../images/contact-media.svg" />
                            <strong>Media Inquiries:</strong><br />
                            <a href="mailto:media@endgame.com">media@endgame.com</a>
                        </p>
                        <p class="general">
                            <img src="../images/contact-general.svg">
                            <strong>General Inquiries</strong><br />
			    <a href="mailto:info@endgame.com">info@endgame.com</a>
                        </p>
                        <p class="location">
                            <img src="../images/contact-location.svg">
                            <a href="../careers/index.html#locations">3101 Wilson Blvd., Suite 500<br />Arlington, VA 22201</a>
                        </p>
			<p class='newsletter'>
			  <img src='../images/icons/mail.svg'>
			  <strong><a href='#' class='js-open-contact-form contact-form-icon'>Sign Up for News</a></strong>
			</p>
                        <p class="social">
                            <a href="https://www.facebook.com/EndgameInc">
                                <img src="../images/icons/facebook.svg" />
                            </a>
                            <a href="https://twitter.com/EndgameInc">
                                <img src="../images/icons/twitter.svg" />
                            </a>
                            <a href="http://www.linkedin.com/company/endgame">
                                <img src="../images/icons/linkedin.svg" />
                            </a>
                        </p>
                    </div>
                </div>
            </ul>
        </nav>
    </header>

    <div role="main" class="boiler">
        <h1>Malware with a Personal Touch</h1>
        
<h3 id="by_casey_gately">by <a href="../archives/index.html">Casey Gately</a></h3>

<p>Over the summer, a friend sent me some malware samples that immediately grabbed my attention. The malware was intriguing because the literal file name of each binary was named after a person or a user ID (for example, bob.exe, bjones.exe, bob_jones.exe, etc). Cool, I thought at first – but after some more detailed analysis, I realized that the malware actually contained hard coded user information, implying that each binary was crafted to target that particular user. Unlike more prominent instances of malware, these samples contained binaries specifically aimed at a pre-generated list of email addresses. No longer is malware targeting only randomized email addresses - this sample indicates a different variety of malware that has a more “personal touch”.</p>

<p>After digging around a bit, it became apparent that this type of malware has been around for a while. Malware of this type was actually circulating during early 2013, but recent open source research revealed there was also a malicious Facebook campaign earlier this year, in May 2014, that delivered similar malware. In the 2014 reports I read, the malware contained embedded clear text bible scripture, but while the samples I received from my friend didn’t contain any bible scripture, there were enough similarities (such as obfuscation techniques and reach back communications) that suggest my variants may have been from the same campaign. In typical phishing fashion, the May campaign began with an email like this:</p>

<p><img src="../uploads/Image1.jpg" alt="Image1.jpg" /></p>

<p>So it’s been around for a little while and there are some other excellent analytical reports on this piece of malware - some of which delve more into the math behind the malware, which is quite interesting. However, in this post, I’ll be focusing on the personalized nature of the malware, which sets it apart from many I have previously analyzed.</p>

<p>Regardless of the malware genesis, what really amazes me is the number of people who will receive an email, download the zip file, then open it using the password provided. They then inadvertently run the malware and receive a fake MessageBox notification created by the malware. This means that while the user probably thought everything was okay, behind the scenes the malware was off and running. Similar to other types of malware, the binaries are triggered by user behavior and continue to run unbeknownst to the infected user. However, unlike many other types, this sample truly contained a personal touch – leveraging social engineering to fool the user that the malware was truly a personalized, benign message. The following section provides a technical walk-through of the various aspects of the malware.</p>

<h3 id="malware_execution_a_step_by_step_overview">Malware Execution: A Step by Step Overview</h3>

<p>Upon execution, the affected user will see an error MessageBox with the following:</p>

<p><img src="../uploads/Image2.jpg" alt="Image2.jpg" /></p>

<p>This would probably lead the unsuspecting user to think the program didn’t work, and there’s a good chance the user would just go about their business. If so, they would never realize their computer had just been compromised, and the seemingly innocent MessageBox would have been the only visual sign of something gone awry.</p>

<p>Now let’s take a closer look at the malware’s footprint on a victim host. It self-replicates to two binaries, both located in a malware-spawned folder within the affected users %AppData% folder. The name of the malware folder and the names of the self-replicated binaries are decoded during run time. What’s interesting about this is that while their naming conventions appear random, they were actually static and quite unique to that particular binary. The names of the folder and each binary are hardcoded, but obfuscated, within the binary. In other words, the malware file structure will be the same each time it is run. Pasted below are three different examples that illustrate this. <em>Note: The literal file names have been intentionally changed to protect the identity of the affected users.</em></p>

<p><img src="../uploads/Image3.jpg" alt="Image3.jpg" /></p>

<p>At first glance, this file structure reminded me of several ZeuS 2.1 and ZeuS-Licat variants I analyzed several years back, but the ZeuS file structure was not static in any way.</p>

<p>The communication flow looks like this. Within the span of 16 seconds, the infected host will connect out to 85 different domains, each with the same GET request.</p>

<p><img src="../uploads/Image4.jpg" alt="Image4.jpg" /></p>

<p>Immediately, a pattern of anomalies can be seen regarding the reach back domains. Like children’s mix and match clothing, the reach back domains are mixed and matched combinations consisting of two English words. Subsequent reversing revealed the malware binary contained an obfuscated list of 384 words, ranging from 6 to 12 letters as follows:</p>

<p>6 letter words = 97 <br />7 letter words = 152 <br />8 letter words = 82 <br />9 letter words = 38 <br />10 letter words = 10 <br />11 letter words = 4 <br />12 letter words = 1</p>

<p>The reach back domains are dynamically generated using a Domain Generation Algorithm (DGA) to merge two of the 384 words together into a single domain name with the “.net” top level domain (TLD). The infected host will connect out to 85 domains, and the list of 85 domains will remain constant for 8:32 minutes, meaning that if the malware is restarted during the same 8 and a half minute period, the same domains would be requested.</p>

<p>For demonstration purposes, if the malware was run at 3:59am on 16 Sep, the domain generation will begin with classshoulder.net, followed by thickfinger.net, etc. (as shown above for connections 1-4). At 4:00am, however, the first domain requested will be thickfinger.net, followed by classfinger.net. Eight minutes later, at 4:09am, the first domain will be classfinger.net, followed by againstbeyond.net. This means that domains 2-85 at 4:00am are identical to domains 1-84 from 3:59am. Below is a representation of the first five domains used between 03:59 and 04:09 AM on 16 September, where the first domain can be seen dropping off after 8 minutes.</p>

<p><img src="../uploads/Image5.jpg" alt="Image5.jpg" /></p>

<p>Referring back to the four connections above, you can see the affected user’s email address is contained within the outbound “GET” via port 80. This too was hardcoded, but obfuscated within the binary and decoded during run time. In essence, this means each binary was crafted for that particular user. Another interesting aspect is that of the variants examined, the domain name list and the affected user information were encoded with different keys.</p>

<p>Now let’s take a quick peek at the malware in action. Once executed, both self-replicated binaries are running processes as shown below:</p>

<p><img src="../uploads/Image6.jpg" alt="Image6.jpg" /></p>

<p>What really intrigued me about this was that these are bit-for-bit copies of each other, and despite this, they are hooked to one another shown above. This seemed quite odd, but diving in a little deeper revealed a more interesting side of the story. Basically the first spawned process (ovwcntv.exe) is the primary running process and the second spawned process (ctrdyelvupa.exe) is a slave process, but more on that later. For now, let’s check out a brief chronological snippet of the malware and its spawned processes during run time.</p>

<p><img src="../uploads/Image7.jpg" alt="Image7.jpg" /></p>

<p>Notice how the original binary (person1.exe) wrote the first copy (ovwcntv.exe) to disk, then spawned its process. Yet ovwcntv.exe was the binary that wrote the second copy (ctrdyelvupa.exe) to disk, subsequently spawning the ctrdyelvupa.exe process. This daisy chain actually acts as a persistency mechanism.</p>

<p>The original binary (person1.exe) is launched via a command line argument. Once running, the binary decodes a string equating to “WATCHDOGPROC”, which the running process looks for. If the “WATCHDOGPROC” string is part of the same command line string as the path for either binary, that particular process is launched. If the “WATCHDOGPROC” string isn’t contained within the same command line string as the binary path, the running process will not launch the additional process. Below are stack excerpts to help demonstrate this.</p>

<p>Will launch:</p>

<pre><code>ASCII &quot;WATCHDOGPROC &quot;C:\Documents and Settings\user\Application Data\nripohbdhnewia\ovwcntv.exe&quot;&quot;</code></pre>

<p>Won’t launch:</p>

<pre><code>ASCII &quot;WATCHDOGPROC&quot;
ASCII &quot;C:\Documents and Settings\user\Application Data\nripohbdhnewia\ovwcntv.exe&quot;</code></pre>

<p>As stated above, the ovwcntv.exe binary is the active running process while ctrdyelvupa.exe acts as a safeguarding (or slave) process. Using the WATCHDOGPROC procedure, if ovwcntv.exe is terminated, ctrdyelvupa.exe immediately restarts it. If ctrdyelvupa.exe is terminated, ovwcntv.exe will restart it as well.</p>

<p>WATCHDOGPROC, in its encoded form, is a 13-byte block embedded in the original binary at offset 00022990. During run time, those bytes are used to populate the ECX register. Each byte is then XOR decoded with the first 13 bytes contained in the EAX register, resulting in the ASCII string “WATCHDOGPROC”. This is demonstrated below.</p>

<p><img src="../uploads/Codeblock2.jpg" alt="Codeblock2.jpg" /></p>

<p>My initial interest in this particular piece of malware, however, was the hardcoded user’s email information that was obfuscated within the binary. I was equally interested in the word list used by the DGA. I wanted to find their embedded location inside the original binary. It was bit of a trek to get there, but persistence paid off in the end. So let’s begin with the encoded user information.</p>

<p>Within the person1.exe binary, the encoded email address was located at offset 00023611, preceded by the encoded uri string (at offset 00023600).</p>

<p><img src="../uploads/Code7.jpg" alt="Code7.jpg" /></p>

<p>During runtime, this data block was stored in the ESI register as shown below:</p>

<p><img src="../uploads/Code8.jpg" alt="Code8.jpg" /></p>

<p>Additionally, a similarly sized block of data was dynamically generated and stored in EAX as shown below. In essence, this was the decoding key.</p>

<p><img src="../uploads/Code9.jpg" alt="Code9.jpg" /></p>

<p>Each byte of ESI and EAX were then run through the following incremental XOR loop…</p>

<p><img src="../uploads/Image8.jpg" alt="Image8.jpg" /></p>

<p>…producing the decoded URI which included the victim user’s email address as shown below.</p>

<p><img src="../uploads/Code10.jpg" alt="Code10.jpg" /></p>

<p>XOR EXAMPLE <br />40 XOR 6F = 2F (‘/‘) <br />6F XOR 09 = 66 (‘f’) <br />6F XOR 00 = 6F (‘o’) <br />56 XOR 24 = 72 (‘r’)</p>

<p><em>Note: once I isolated the user data (or email address) within the original binary, along with its key, I patched the binary so it would reflect ‘nottherealuser’ vice the name of the actual victim user. This patched binary was then used to obtain the previous examples.</em></p>

<p>Next, let’s look at the domain name generation. It followed the same scheme as above. A 2800-byte block of hardcoded data from the original binary was stored in ESI. Then an equally sized block of data was dynamically generated and stored in EAX. These two data blocks were run through the same XOR loop producing a list of 384 words. To demonstrate this, the first 48 bytes of the applicable registers are shown below.</p>

<p><img src="../uploads/Code11.jpg" alt="Code11.jpg" /></p>

<p>XOR EXAMPLE <br />FB XOR 91 = 6A (‘j‘) <br />4A XOR 25 = 6F (‘o’) <br />0A XOR 7F = 75 (‘u’) <br />30 XOR 42 = 72 (‘r’) <br />4C XOR 22 = 6E (‘n’) <br />3F XOR 5A = 65 (‘e’) <br />46 XOR 3F = 79 (‘y’)</p>

<p>The interesting part about this binary was that while it appeared packed, it wasn’t. Just about everything within the binary (API calls, strings, etc.) was obfuscated and decoded on the fly during run time as needed. Also, it didn’t debug on its own freewill. This became apparent while stepping through the binary and hitting a point where EIP was set to 00000000. To overcome this, the binary was patched at that particular offset by changing the opcode to a jump (EB FE) so that it would loop back to itself during run time. The patched binary was then saved and executed again, causing it to run in an infinite loop. While running, a debugger was attached to the binary. The jump opcode (EB FE) was then changed back to its original opcode (FF 15 in this case) at which time the intended location of that call (address 00409C50) appeared as can be seen in the following debugger excerpt:</p>

<p><img src="../uploads/Code12.jpg" alt="Code12.jpg" /></p>

<p>At this point, the binary was patched with a call to the newly identified offset by replacing “CALL DWORD PTR DS:[42774C]” (shown above) with “CALL 409C50”. After this, the binary was saved to a new binary (e.g. binary1.exe).</p>

<p>Next, binary1.exe was loaded into a debugger and a break point was set for CreateProcessA. The binary was then run which generated the first copy of the original binary (in this case ovwcntv.exe), but for simplicity’s sake, we’ll call this binary2.exe.</p>

<p>Binary2.exe was then loaded into a debugger and as we did previously, the opcode at the initial point of user code (E8 48 in this case) was changed to EB FE, changing the initial command from CALL to JMP, as follows:</p>

<p><img src="../uploads/CodeFrom.jpg" alt="CodeFrom.jpg" /></p>

<p>to</p>

<p><img src="../uploads/CodeTo.jpg" alt="CodeTo.jpg" /></p>

<p>Binary2.exe was then saved as itself, overwriting the original binary2.exe. It also created a backup copy (.bak), which was deleted. Then the debugger was closed.</p>

<p>After this, a debugger was reopened, but it wasn’t attached to anything just yet. Returning to the still-opened debugger for binary1.exe, Alt F9 was pressed in order to execute the binary til user code. This caused binary2.exe to run in a loop (due to the aforementioned patch). The newly opened debugger was then attached to binary2.exe, opening the binary in the ntdll module. From the debugger for binary2.exe, Alt F9 was pressed in order to run it til user code. At this point, the opcode EB FE was changed back to its original opcode (in this case E8 48). A breakpoint was then placed for LoadLibraryA and the binary was run again. Stepping through the binary back into the user code led to all the deobufuscation discussed earlier.</p>

<p>Lastly, below is the complete list of words used for the creation of reach back domains, in order of the lists creation (reading left to right):</p>

<p><img src="../uploads/Image9.jpg" alt="Image9.jpg" /></p>

        <!-- Go to www.addthis.com/dashboard to customize your tools -->
        <div class="addthis_native_toolbox"></div>

        <!-- Go to www.addthis.com/dashboard to customize your tools -->
		<script type="text/javascript" src="http://s7.addthis.com/js/300/addthis_widget.js#pubid=ra-53c7dc1328ec3211"></script>

    </div>

    <footer class='site__footer cf'>
      <div class='wrapper'>
      <div class='f-left'>
	<small>&copy; Endgame 2014. All Rights Reserved | Subscribe to our <a href="../feed.xml" target="_blank">RSS</a> feed</small>
      </div>
      <div class='f-right'>
	<a class='logo' href="../index.html">
	  <img alt="Endgame logo" src="../images/logo.svg">
	</a>
      </div>
    </div><!--//wrapper-->
    </footer>
    
    <a href='#top' class='js-top top'></a>
    <script src="../javascripts/jquery.js"></script>
    <script src="../javascripts/waypoints.min.js"></script>
    
    
    <script src="../javascripts/jquery.cycle2.min.js"></script>
    <script src="../javascripts/app.js"></script>
    
</body>

<!-- Mirrored from www.endgame.com/blog/malware-with-a-personal-touch.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 18 Nov 2014 14:45:35 GMT -->
</html>
